---
title: pep8
date: 2020-12-4
tags:
mathjax: true
---



注释前言

···

<!-- more -->

[PEP8英文版网址](https://legacy.python.org/dev/peps/pep-0008/#introduction)

[PEP8中文翻译1](https://python.freelycode.com/contribution/detail/47)

[PEP8中文翻译2](https://blog.csdn.net/ratsniper/article/details/78954852#function-and-method-arguments-%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0)



- 缩进：每一级缩进使用4个空格。

- 续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐。

- 当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。

- 挂行缩进是一种类型设置样式，其中除第一行之外，段落中的所有行都缩进。在Python中，这个术语是用来描述一种风格：在被括号括起来的语句中，左括号是这一行最后一个非空格字符，随后括号内的内容每一行进行缩进，直到遇到右括号。

- 四空格的规则对于续行是可选的。

- 

- if语句条件块足够长时需要编写多行，值得注意的是两个字符组成的关键字（例如if），加上一个空格，加上开括号为多行条件的后续行创建一个4个空格的缩进。这可以给嵌入if内的缩进语句产生视觉冲突，这也自然被缩进4个空格。这个PEP没有明确如何（是否）进一步区分条件行和if语句内的嵌入行。

- 

- 在多行结构中的大括号/中括号/小括号的右括号可以与内容对齐单独起一行作为最后一行的第一个字符，或者也可以与多行结构的第一行第一个字符对齐。

- 空格是首选的缩进方式。Python3不允许同时使用空格和制表符的缩进。

- 所有行限制的最大字符数为79。

- 没有结构化限制的大块文本（文档字符或者注释），每行的最大字符数限制在72。

- 较长的代码行选择Python在小括号，中括号以及大括号中的隐式续行方式。通过小括号内表达式的换行方式将长串折成多行。这种方式应该优先使用，而不是使用反斜杠续行。

- 反斜杠有时依然很有用。

- 为了解决可读性问题，数学家和印刷业者通常是在二元操作符之前换行的。

  

- 顶级函数和类的定义之间有两行空行。

- 类内部的函数定义之间有一行空行。

- 额外的空行用来（谨慎地）分离相关的功能组。相关的行（例如：一组虚拟实现）之间不使用空行。

- 在函数中谨慎地使用空行来表示逻辑部分。

- Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。



- Python核心发布中的代码应该始终使用UTF-8（或Python2中用ASCII）。
- 文件使用ASCII（Python2中）或UTF-8（Python3中）不应有编码声明。
- 在标准库中，非默认编码仅用于测试目的或注释或文档字符串需要提及包含非ASCII字符的作者名；否则，使用\x，\u，\U，或\N是字符串中包含非ASCII数据的首先方式。
- 对于Python 3和更高版本，标准库规定了以下策略（参见 [PEP 3131](http://legacy.python.org/dev/peps/pep-3131/)）：Python标准库中的所有标识符必须使用ASCII标识符，并在可行的情况下使用英语单词（在许多情况下，缩写和技术术语是非英语的）。此外，字符串文字和注释也必须是ASCII。唯一的例外是（a）测试非ASCII特征的测试用例，以及（b）作者的名称。作者的名字如果不使用拉丁字母拼写，必须提供一个拉丁字母的音译。



- 导入通常是单独一行

- 导入常常位于文件顶部，在模块注释和字符串文档之后，在模块的全局变量和常量之前。

- 导入应该按照以下顺序分组：
  1. 标准库导入
  
  2. 相关的第三方导入

  3. 特定的本地应用/库导入
  
  在每个导入组之间放一行空行。
  
- 推荐绝对导入，因为它们更易读，并且如果导入系统配置的不正确（例如当包中的一个目录结束于sys.path）它们有更好的表现（至少给出更好的错误信息）

- 明确的相对导入可以用来接受替代绝对导入，特别是处理复杂包布局时，绝对导入过于冗长。

- 标准库代码应该避免复杂包布局并使用绝对导入。

- 隐式的相对导入应该永远不被使用，并且在Python3中已经移除。

- 避免使用通配符导入（from <模块名> import *），因为它们使哪些名字出现在命名空间变得不清楚，这混淆了读者和许多自动化工具。通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分





- 模块级别的内置属性（名字有前后双下划线的），例如\__all\__, \__author\__,  \__version\__，应该放置在模块的文档字符串后，任意import语句之前，from \__future\__导入除外。Python强制要求from \__future\__导入必须在任何代码之前，只能在模块级文档字符串之后。



- Python中，单引号字符串和双引号字符串是一样的。本PEP不建议如此。建议选择一条规则并坚持下去。当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠。这提高可读性。
- 对于三引号字符串，总是使用双引号字符来与[PEP 257](http://legacy.python.org/dev/peps/pep-0257/)中的文档字符串约定保持一致。



- 以下情况避免使用多余的空格：
  - 紧挨着小括号，中括号或大括号。
  - 紧挨在逗号，分号或冒号前：
  - 在切片中冒号像一个二元操作符，冒号两侧的有相等数量空格（把它看作最低优先级的操作符）。在一个扩展切片中，两个冒号必须有相等数量的空格。例外：当一个切片参数被省略时，该空格被省略。
  - 紧挨着左括号之前，函数调用的参数列表的开始处：
  - 紧挨着索引或切片开始的左括号之前：
  - 为了与另外的赋值（或其它）操作符对齐，不止一个空格。
- 始终避免行尾空白。因为它们通常不可见，容易导致困惑：如果\后面跟了一个空格，它就不是一个有效的续行符了。
- 始终在这些二元操作符的两边放置一个空格：赋值（= ），增强赋值（+= ，-= 等），比较（== ， < ， > ， != ， <> ， <= ， >= ，in ， not in ，is ，is not ），布尔（and ，or ，not ）。
- 如果使用了不同优先级的操作符，在低优先级操作符周围增加空格（一个或多个）。不要使用多于一个空格，二元运算符两侧空格数量相等。
- 当=符号用于指示关键字参数或默认参数值时，它周围不要使用空格。
- 带注解的函数使用正常的冒号规则，并且在->两侧增加一个空格：
- 如果参数既有注释又有默认值，在等号两边增加一个空格（仅在既有注释又有默认值时才加这个空格）。
- 不鼓励使用复合语句（同一行有多条语句）。
- 尽管有时if/for/while的同一行跟一小段代码，在一个多条子句的语句中不要如此。避免折叠长行！



- 尾部逗号通常都是可选的，除了一些强制的场景，比如元组在只有一个元素的时候需要一个尾部逗号。为了代码更加清晰，元组只有一个元素时请务必用括号括起来（语法上没有强制要求）
- 当尾部逗号不是必须时，如果你用了版本控制系统那么它将很有用。当列表元素、参数、导入项未来可能不断增加时，留一个尾部逗号是一个很好的选择。通常的用法是（比如列表）每个元素独占一行，然后尾部都有逗号，在最后一个元素的下一行写闭标签。如果你的数据结构都是写在同一行的，就没有必要保留尾部逗号了。



**注释**

- 同代码相矛盾的注释比没有注释更差。当代码修改时，始终优先更新注释！
- 注释应该是完整的句子。如果注释是一个短语或句子，它的第一个单词的首字母应该大写，除非它是一个以小写字母开头的标识符（不更改标识符的情况下！）。
- 如果注释很短，末尾可以不加句号。注释块通常由一个或多个段落组成，这些段落由完整的句子组成，并且每个句子都应该以句号结尾。
- 在句尾的句号后边使用两个空格。
- 写英语注释时，遵循断词和空格。
- 非英语国家的Python程序员：请用英语书写注释，除非你120%的确定，所有看你代码的人都和你说一样的语言。
- 非英语国家的Python程序员：请写下你的意见，在英语中，除非你是120%肯定，代码将不会被不讲你的语言的人阅读。



**注释块**

- 注释块通常适用于一些（或全部）紧跟其后的代码，并且那些代码应使用相同级别的缩进。注释块的每行以一个#和一个空格开始（除非注释里面的文本有缩进）。
- 注释块内的段落之间由仅包含#的行隔开。



**行内注释**

- 谨慎地使用行内注释。
- 行内注释就是注释和代码在同一行，它与代码之间至少用两个空格隔开。并且它以#和一个空格开始。



**文档字符串**

- 要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。
- [PEP 257](http://legacy.python.org/dev/peps/pep-0257/) 描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行，
- 对于单行的文档说明，尾部的三引号应该和文档在同一行。



**命名规范**

- 新模块和包（包括第三方框架）应该按这些标准书写，但对有不同的风格的已有库，保持内部一致性是首选。

**根本原则**

- 用户可见的API的公开部分的名称，应该遵循反映用法而不是实现的约定。

**描述：命名风格**

以下是常见的命名方式：

- b（单个小写字母）
- B（单个大写字母）
- lowercase 小写字母
- lower_case_with_underscores 使用下划线分隔的小写字母
- UPPERCASE 大写字母
- UPPER_CASE_WITH_UNDERSCORES 使用下划线分隔的大写字母
- CapitalizedWords（或者叫 CapWords，或者叫CamelCase 驼峰命名法 —— 这么命名是因为字母看上去有起伏的外观[5](https://blog.csdn.net/ratsniper/article/details/78954852#fn:4)）。有时候也被称为StudlyCaps。
  注意：当在首字母大写的风格中用到缩写时，所有缩写的字母用大写，因此，HTTPServerError 比 HttpServerError 好。
- mixedCase（不同于首字母大写，第一个单词的首字母小写）
- Capitalized_Words_With_Underscores（巨丑无比！）



下面这种用前缀或结尾下划线的特殊格式是被认可的（通常和一些约定相结合）：

- _single_leading_underscore：（单下划线开头）弱“内部使用”指示器。比如 from M import * 是不会导入以下划线开始的对象的。
- single_trailing_underscore_：（单下划线结尾）这是避免和Python内部关键词冲突的一种约定，比如：Tkinter.Toplevel(master, class_=’ClassName’)
- `__double_leading_underscore`：（双下划线开头）当这样命名一个类的属性时，调用它的时候名字会做矫正（在类FooBar中，`__boo`变成了`_FooBar__boo`；见下文）。
- `__double_leading_and_trailing_underscore__`：（双下划线开头，双下划线结尾）“magic”对象或者存在于用户控制的命名空间内的属性，例如：`__init__`,`__import__`或者`__file__`。除了作为文档之外，永远不要命这样的名。



**避免采用的名字**

- 不要使用字符‘l’（小写字母el），‘O’（大写字母oh）或‘I’（大写字母eye）作为单字符变量名。在某些字体中，这些字符与数字1和0是没有区别的。当想使用‘l’时，用‘L’代替。

**包名和模块名**

- 模块名应该短，所有的字母小写。可以在模块名中使用下划线来提高可读性。Python包名也应该短，所有的字母小写，不鼓励使用下划线。
- 当使用C或者C++编写了一个依赖于提供高级（更面向对象）接口的Python模块的扩展模块，这个C/C++模块需要一个下划线前缀（例如：_socket）

**类名**

- 类名通常使用首字母大写字符串的规则。
- 在接口被记录并且主要用作调用的情况下，用函数的命名规则来代替类名的命名规则。
- 对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。

**异常名**

- 因为异常应该是类，所以类的命名规则在这里也同样适用。然而，异常名（如果这个异常确实是一个错误）应该使用后缀“Error”。

**全局变量名**

- （希望这些变量是在一个模块内使用。）这些规则和那些有关函数的规则是相同的。
- 模块设计为通过from M import *来使用，应使用\__all\__机制防止导出全局变量，或使用加前缀的旧规则，为全局变量加下划线（可能你像表明这些全局变量是“非公开模块”）。

**函数名**

- 函数名应该是小写字母，必要时单词用下划线分开以提高可读性。
- 混合大小写仅用于这种风格已经占主导地位的上下文（例如threading.py），以保持向后兼容性。

**函数和方法参数**

- 使用self做实例化方法的第一个参数。
- 使用cls做类方法的第一个参数。
- 如果函数的参数名与保留关键字冲突，最好是为参数名添加一个后置下划线而不是使用缩写或拼写错误。因此class_ 比clss好。（也许使用同义词来避免更好）。

**方法名和实例变量**

- 遵循这样的函数命名规则：使用下划线分隔小写单词以提高可读性。
- 在非共有方法和实例变量前使用单下划线。
- 通过双下划线前缀触发Python的命名转换规则来避免和子类的命名冲突。
- Python通过类名对这些命名进行转换：如果类 Foo 有一个叫 `__a` 的成员变量， 它无法通过 `Foo.__a` 访问。（执着的用户可以通过 `Foo._Foo__a` 访问。）一般来说，前缀双下划线用来避免类中的属性命名与子类冲突的情况。
  注意：关于`__names`的用法存在争论（见下文）。

**常量**

- 常量通常定义于模块级别并且所有的字母都是大写，单词用下划线分开。例如MAX_OVERFLOW和TOTAL。

**继承的设计**

- 确定类的方法和实例变量（统称为：“属性”）是否公开。如果有疑问，选择非公开；之后把其变成公开比把一个公开属性改成非公开要容易。
- 公共属性是那些与类无关的客户使用的属性，并承诺避免向后不兼容的更改。非共有属性是那些不打算让第三方使用的属性；你不需要承诺非共有属性不会被修改或被删除。
- 我们不使用“私有（private）”这个说法，是因为在Python中目前还没有真正的私有属性（为了避免大量不必要的常规工作）。
- 另一种属性作为子类API的一部分（在其他语言中通常被称为“protected”）。有些类是专为继承设计的，用来扩展或者修改类的一部分行为。当设计这样的类时，要谨慎决定哪些属性时公开的，哪些是作为子类的API，哪些只能在基类中使用。



贯彻这样的思想，一下是一些让代码Pythonic的准则：

- 公共属性不应该有前缀下划线。
- 如果公共属性名和关键字冲突，在属性名之后增加一个下划线。这比缩写和随意拼写好很多。（然而，尽管有这样的规则，在作为参数或者变量时，‘cls’是表示‘类’最好的选择，特别是作为类方法的第一个参数。）
  注意1：参考之前的类方法参数命名建议
- 对于单一的共有属性数据，最好直接对外暴露它的变量名，而不是通过负责的 存取器（accessor）/突变（mutator） 方法。请记住，如果你发现一个简单的属性需要成长为一个功能行为，那么Python为这种将来会出现的扩展提供了一个简单的途径。在这种情况下，使用属性去隐藏属性数据访问背后的逻辑。
  注意1：属性只在new-style类中起作用。
  注意2：尽管功能方法对于类似缓存的负面影响比较小，但还是要尽量避免。
  注意3：属性标记会让调用者认为开销（相当的）小，避免用属性做开销大的计算。
- 如果你的类打算用来继承的话，并且这个类里有不希望子类使用的属性，就要考虑使用双下划线前缀并且没有后缀下划线的命名方式。这会调用Python的命名转换算法，将类的名字加入到属性名里。这样做可以帮助避免在子类中不小心包含了相同的属性名而产生的冲突。
  注意1：只有类名才会整合进属性名，如果子类的属性名和类名和父类都相同，那么你还是会有命名冲突的问题。
  注意2：命名转换会在某些场景使用起来不太方便，例如调试，`__getattr__()`。然而命名转换的算法有很好的文档说明并且很好操作。
  注意3：不是所有人都喜欢命名转换。尽量避免意外的名字冲突和潜在的高级调用。



**程序设计建议**

- 编写的代码应该不损害其他方式的Python实现（PyPy，Jython，IronPython，Cython，Psyco等等）。
- 例如，不要依赖CPython的高效实现字符串连接的语句形式 += b或a = a + b。这种优化即使在CPython里也是脆弱的（它只适用于某些类型），并且在不使用引用计数的实现中它完全不存在。在库的性能易受影响的部分，应使用''.join()形式。这将确保跨越不同实现的连接发生在线性时间。

- 与单值比如None比较使用is 或is not ，不要用等号操作符。

- 另外，如果你在写 if x 的时候，请注意你是否表达的意思是 if x is not None。举个例子，当测试一个默认值为None的变量或者参数是否被设置为其他值的时候。这个其他值应该是在上下文中能成为bool类型false的值。

- 使用 is not 运算符，而不是 not … is 。虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。

- 当使用富比较（rich comparisons，一种复杂的对象间比较的新机制，允许返回值不为-1,0,1）实现排序操作的时候，最好实现全部的六个操作符（`__eq__`, `__ne__`, `__lt__`, `__gt__`, `__ge__`）而不是依靠其他的代码去实现特定的比较。

  为了最大程度减少这一过程的开销， functools.total_ordering() 修饰符提供了用于生成缺少的比较方法的工具。

- 使用def语句而不是使用赋值语句将lambda表达式绑定到标识符上。

- 从Exception而不是BaseException中派生出异常。直接继承BaseException是保留那些捕捉几乎总是错的异常的。

- 捕获异常时，尽可能提及特定的异常，而不是使用空的except：子句。

- 空的except：子句将捕获SystemExit和KeyboardInterrupt异常，这使得很难用Control-C来中断程序，也会掩饰其它的问题。如果想捕获会导致程序错误的所有异常，使用except Exception:（空异常相当于except BaseException:）
  一条好的经验法则是限制使用空‘except’子句的两种情况：

  ​    1.如果异常处理程序将打印或记录跟踪；至少用户将会意识到有错误发生。
  ​    2.如果代码需要做一些清理工作，但是随后让异常用raise抛出。处理这种情况用try...finally更好。

- 返回语句保持一致。函数中的所有返回语句都有返回值，或都没有返回值。如果任意一个返回语句有返回值，那么任意没有返回值的返回语句应该明确指出return None，并且明确返回语句应该放在函数结尾（如果可以）。
- 使用字符串方法代替string模块。
- 字符串方法总是更快并且与unicode字符串使用相同的API。如果必须向后兼容Python2.0以前的版本，无视这个原则。
- 使用“.startswith() ”和“.endswith()”代替字符串切片来检查前缀和后缀。startswith()和endswith()更清晰，并且减少错误率

- 对象类型的比较使用isinstance()代替直接比较类型。

- 当检查一个对象是否是字符串时，牢记它也可能是一个unicode字符串！Python 2中，str和unicode有共同的基类basestring
- 注意，Python3中， unicode和basestring不再存在（只有str），并且字节对象不再是string（而是一个integers序列）
- 对于序列（字符串，列表，元组），利用空序列是false的事实。
- 不要书写依赖后置空格的字符串。这些后置空格在视觉上无法区分，并且有些编辑器（或最近，reindent.py）将去掉他们。
- 不要用==来将布尔值与True或False进行比较。
- 



























