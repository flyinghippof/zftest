---
title: c++程序设计_北大
date: 2020-10-14
tags:

---

学习笔记

文件操作和模板之后的内容没看，先开始刷题，要不然都忘了



<!-- more -->

# c从C走进C++

## 函数指针

- 定义：可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以调用这个函数。这种指向函数的指针变量称为“函数指针”。

- 定义形式：类型名（*指针变量名）（参数类型1，参数类型2，.....）;

- eg：int（*pf）（int，char）;   --含义：pf为函数指针，指向某个函数，该函数返回值类型为int，函数参数为（int，char）

- 使用方法：可以用一个原型匹配的函数的名字给一个函数指针赋值。

- 要通过函数指针调用其指向的函数，写法为：函数指针名（实参表）；

- 函数指针和qsort库函数：

  - qsort可以对任意类型的数组进行排序，形式如下：

    void qsort（void *base, int nelem, unsigned int width, int(\*pfCompare)(const void \*,const void \*)）;

  - base：待排序数组的起始地址

  - nelem：待排序数组的元素个数

  - width：待排序数组的每个元素的大小（以字节为单位）

  - pfCompare：比较函数的地址

  - pfCompare：函数指针，指向一个比较函数，形式如下：

    int 函数名（const void * elem1，const void * elem2）；

  - 比较函数规则：

    - 如果* elem1在* elem2前面，则函数返回值是负整数
    - 如果* elem1在* elem2哪个在前边均可，则函数返回值是0
    - 如果* elem1在* elem2后面，则函数返回值是正整数

## 命令行参数

- 在CMD窗口，跟在可执行文件名后边的那些字符串，称为“命令行参数”。

```c
int main(int argc, char * argv[]){
    ......
}
```

- argc：代表启动程序时，命令行参数的个数。C/C++规定，可执行程序程序本身的文件名，也算一个命令行参数，因此，argc的值至少是1.
- argv：指针数组，其中的每个元素都是一个char*类型的指针，该指针指向一个字符串，这个字符串里就存放着命令行参数。
- 命令行参数本身就是用空格来分隔的，但是如果本身命令行参数就带空格，可以用双引号引起来

## 位运算

C/C++六种位运算符：

1. &--按位与

   - 可用来：某些位清0且同时保证其他位不变

   - 也可用来：获取某变量中的某一位

2. |--按位或

   将变量中的某些位置1且保留其他位不变

3. ^--按位异或

   - 将某变量中的某些位取反，且保留其他位不变

   - 如果a\^b=c，那么c\^b=a 以及c^a=b

   - 不通过临时变量，交换两个变量的值：a = a \^ b; b = b \^ a; a = a \^ b; 

4. ~--按位非

5. <<--左移

   - a<<b：将a各二进制位全部左移b位，不会修改a的值
   - 左移n位，相当于乘2^n^，而且左移比乘法操作快的多

6. \> >--右移

   右移n位，相当于把左操作数除以2^n^，并且结果往小里取整

## 引用

- 定义：类型名 & 引用名 = 某变量名；

- 某个变量的引用，等价于这个变量，相当于该变量的一个别名
- 注意的点：
  - 定义引用时一定要将其初始化成引用某个变量
  - 初始化后，它就一直引用该变量，不会再引用别的变量了
  - 引用只能引用变量，不能引用常量和表达式

- 引用可以作为函数的返回值
- 常引用，定义引用时，前边加const关键字，即为“常引用”。
  - 不能通过常引用去修改其引用的内容，但是不代表其内容不能被修改
  - const T & 和 T & 是不同的类型。
  -  T & 类型的引用或T类型的变量可以用来初始化const T &类型的引用
  - const T 类型的常变量和const T &类型的引用不能用来初始化T &类型的引用，除非进行强制类型转换。

- 指针和引用的区别：

  - 本质上：引用是别名，指针是地址

  - 现象上：指针在运行时可以改变所指向的值，而引用一旦与某个对象绑定后就不再改变。

  - 内存分配：程序为指针变量分配区域，而不为引用分配内存区域。因为引用生命时必须初始化，从而指向一个已经存在的对象，**引用不能为空值**。

  - 编译：程序在编译时分别将指针和引用添加到**符号表**上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为**指针变量的地址值**，而引用在符号表上对应的地址值为**引用对象的地址值**。从某种意义上来说**引用可以被认为是不能改变的指针**。

  - 级数：从理论上来说，对于指针没有级数限制，但是引用只有一级。指向引用的引用是非法的

    

## CONST

- 定义常量
- 定义常量指针
  -  const int * p = & n；
  -  不可通过常量指针修改其指向的内容（其内容可被修改），
  - 且常量指针的指向可以变化
  - 不能把常量指针赋值给非常量指针，反过来可以
  - 函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容。

- 定义常引用

  不能通过常引用修改其引用的变量



## 动态内存分配

- 用new运算符实现动态内存分配

1. 分配一个变量  P = new T；T是任意类型名，P是类型为T * 的指针。

   ​	动态分配一片大小为sizeof（T）字节的内存空间，并且将该内存空间起始地址赋给P

2. 分配一个数组 P = new T[N]；T是任意类型名，P是类型为T * 的指针，N是要分配的数组元素的个数，可以是整型表达式

   ​	动态分配一片大小为N*sizeof（T）字节的内存空间，并且将该内存空间起始地址赋给P

- new运算符的返回值的类型：是new出来的数据类型的指针

- 用new动态分配的内存空间，一定要用delete运算符进行释放。

  delete 指针； 该指针必须指向new出来的空间，别的变量指针等会出错

- 用delete释放动态分配的数组，要加[]

  delete [] 指针；

## 内联函数和重载函数

内联函数：

- 函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。
- 为了减少函数调用的开销，引入内联函数机制。编译器对内联函数调用时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。
- 在函数定义前面加“inline”关键字，即可定义内联函数。

函数重载：

- 一个或多个函数，名字相同，然而**参数个数**和**参数类型**不相同，这叫做函数的重载。

- 函数重载使得函数命名变得简单

- 编译器根据调用语句中的实参的个数和类型判断应该调用哪个函数。

- eg：

  ```c
  int max(double f1, double f2){}
  int max(int n1,int n1){}
  int max(int n1,int n2,int n3){}
  ```

## 函数缺省参数

- 定义函数的时候可以让最右边的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。
- 函数参数可缺省的目的在于提高程序的可扩充性。
- 如果某个写好的函数要添加新的参数，而原先哪些调用该函数的语句，未必需要使用新增的参数，那么为了避免对这些函数进行修改，就可以使用缺省参数。

## 面向对象程序设计方法

类

```c
class 类名{
    访问范围说明符：
        成员变量1
        成员变量2
        ...
        成员函数声明1
        成员函数声明2
    访问范围说明符：
        更多成员变量
        更多成员函数声明
        ...  
}; //必须有分号
```

## 面向对象语言的发展历程

发展历程

## 从客观事物抽象出类的例子

类定义例子;

```c++
class CRectangle
{
    public:
    	int w,h;
	void Init(int w_, int h_){
    	w = w_; h = h_;
	}
    int Area(){
    	return w*h;
	}
	int Perimeter(){
    	return 2*(w+h);
	}
};
```

类调用例子：

```c++
int main(){
    int w,h;
    cin>>w>>h;
    r.Init(w,h);
    cout<<r.Area()<<endl<<r.Perimeter();
    return 0;
}
```

对象的内存分配：

- 对象的大小等于所有成员变量的大小之和
- 每个对象各有自己的存储空间，一个对象的某个成员变量被改变，不会影响到其他的对象

对象间的运算：

- 对象之间可以用‘=’进行赋值
- 不能用‘==’，‘！=’，‘>’,'<','<=','>='进行比较，除非这些运算符经过了重载

访问类的成员变量和成员函数：

- 用法1：对象名.成员名
- 用法2：指针->成员名
- 用法3：引用名.成员名

类的成员函数的另一种写法（成员函数体和类的定义分开写）：

```c++
class CRectangle
{
    public:
    	int w,h;
        int Area();
        int Perimeter();
        void Init(int w_, int h_);
};

int CRectangle::Area(){
    return w*h;
}
int CRectangle::Perimeter(){
    return 2*(w+h);
}
void CRectangle::Init(int w_, int h_){
    w = w_; h = h_;
}
```

## 类成员的可访问范围 

通过关键字确定类成员可被访问的范围：

- private：指定私有成员，只能在成员函数内被访问
- public：指定共有成员，可以在任何地方被访问
- protected：指定保护成员
- 三种关键字出现的次数和先后次序都没有限制
- 缺省为私有成员

对象成员的访问权限：

- 类的成员函数内部，可以访问：
  - 当前对象的全部属性，函数
  - 同类其他对象的全部属性，函数
- 类的成员函数以外的地方：
  - 只能够访问该类对象的公有成员（public）

设置私有成员的目的：

- 强制对成员变量的访问一定要通过成员函数进行

# 类和对象

## 内联成员函数和重载成员函数

 内联成员函数定义方式：

1. inline + 成员函数
2. 整个函数体出现在类定义内部



- 成员函数也可以有重载的操作，同时也可以带缺省参数。
- 使用缺省参数要注意避免有函数重载时的二义性

## 构造函数

- 成员函数的一种
- 名字与类名相同，可以有参数，不能有返回值（void也不行）
- 作用是对对象进行初始化，如给成员变量赋初值
- 如果定义类时，没写构造函数，则编译器生成一个默认的无参数的构造函数，默认构造函数无参数，不做任何操作
- 对象生成时构造函数自动被调用。对象一旦生成，就再也不能在其上执行构造函数
- 一个类可以有多个构造函数，参数个数或类型不同，构成重载的关系

eg：

```c++
class Complex{
    private:
    	double real,imag;
    public:
    	Complex(double r,double i = 0);
};
Complex::Complex(double r,double i){
    real = r;imag = i;
}
```

构造函数在数组中的使用：

可以构建数组型的对象，每个数组元素里边都有一个对象。

## 复制构造函数

- 只有一个参数，即**对同类对象的引用**
- 形如X::X(X&) 或 X::X(const X&)，二者选一，后者能以常量的对象作为参数
- 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。
- 如果定义自己的复制构造函数，则默认的复制构造函数不存在。
- 不允许有形如X::X(X) 的构造函数

复制构造函数起作用的三种情况：

- 当用一个对象去初始化同类的另一个对象时。
- 如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。
- 如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。

## 类型转换构造函数

- 目的：实现类型的自动转换
- 特点：1. 只有一个参数 2. 不是复制构造函数
- 使赋值语句左右不一致的赋值变得一致化
- 其会生成一个临时变量

## 析构函数

- 成员函数的一种，名字与类名相同
- 在前边加‘~’
- 没有参数和返回值
- 一个类最多只有一个析构函数
- 在对象消亡时，自动的被调用
- 定义类时没写析构函数，则编译器生成缺省析构函数，定义了析构函数，则编译器不生成缺省析构函数。
- 对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用。
- delete 运算也会导致析构函数的调用
- 离对象最近的一对‘{}’表征了对象的作用范围，离开了该作用域，对象析构
- 先被构造的对象会最后被析构掉

## 静态成员变量和静态成员函数

- 静态成员：在说明前面加了static关键字的成员。静态成员变量和静态成员函数。
- 普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享
- sizeof 运算符不会计算静态成员变量。
- 普通成员函数必须作用域某个对象，而静态成员函数并不具体作用于某个对象
- 因此，静态成员不需要通过对象就可以访问

如何访问静态成员：

1. 类名::成员名    CRectangle::PrintTotal();
2. 对象名.成员名    CRectangle r; r.PrintTotal();
3. 指针->成员名   CRectangle *p = &r; p->PrintTotal();
4. 引用.成员名    CRectangle &ref  = r; int n = ref.TotalNumber;

- 静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在
- 静态成员函数本质上是全局函数。
- 必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。
- 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。

## 成员对象和封闭类的概念

- 成员对象：一个类的成员变量是另一个类的对象

- 包含成员对象的类叫封闭类

- ```c++
  class CTyre{
      private:
      	int radius;
      	int width;
      public:
      	CTyre(int r,int w):radius(r),width(w){}; //列表初始化
  };
  ```

- 封闭类构造函数的初始化列表

  - 定义封闭类的构造函数时，添加初始化列表：

  ```c++
  类名::构造函数（参数表）:成员变量1（参数表），成员变量2（参数表），....
  {
      ....
  }
  ```

  - 成员你对象初始化列表中的参数
    - 任意复杂的表达式
    - 函数/变量/表达式中的函数，变量有定义

- 调用顺序

  - 当封闭类对象生成时，
    - 先执行所有成员对象的构造函数
    - 再执行封闭类的构造函数
  - 成员对象的构造函数的调用顺序
    - 和成员对象在类中的说明顺序一致
    - 与在成员初始化列表中出现的顺序无关
  - 在封闭类的对象消亡时，
    - 先执行封闭类的析构函数
    - 再执行成员对象的析构函数
  - 析构函数顺序和构造函数的调用顺序相反

## 友元

友元函数：

- 一个类的私有成员只能是内部的成员函数来进行访问，但是一个类的友元函数可以访问该类的私有成员。利用friend关键字声明友元
- 可以将一个类的成员函数（包括构造和析构函数）声明成另一个类的友元

友元类：

- A是B的友元类，则A的成员函数可以访问B的私有成员
- 友元类之间的关系不能传递，不能继承

## this指针

- 感觉有点类似于python的self

- C++到C的翻译示例：

  ```c++
  // C++
  class CCar{
      public:
      	int price;
      	void SetPrice(int p);
  };
  void CCar::SetPrice(int p)
  {price = p;}
  int main()
  {
      CCar car;
      car.SetPrice(20000);
      return 0;
  }
  ```

  ```c
  // C
  struct CCar{
      int price;
  };
  void SetPrice(struct CCar * this,int p)
  { this->price = p;}
  int main(){
      struct CCar car;
      SetPrice(&car,20000);
      return 0;
  }
  ```

  

- this指针的作用
  - 就是指向成员函数所作用的对象
  - 非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针
- this指针和静态成员函数
  - 静态成员函数中不能使用this指针
  - 因为静态成员函数并不具体作用于某个对象
  - 因此，静态成员函数的真实的参数个数就是程序中写出的参数个数

## 常量对象、常量成员函数和常引用

常量对象：

- 常量对象不可被修改

- 如果不希望某个对象的值被改变，则定义该对象的时候可以在**前面**加const关键字

常量成员函数：

- 在类的成员函数**后面**可以加const关键字，则该成员函数成为常量成员函数。
- 常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。

注意：

- 常量对象上面不能执行非常量成员函数。
- 常量对象上可以执行常量成员函数。

常量成员函数的重载：

- 两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载

常引用：

- 引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量。

# 运算符重载

## 运算符重载的基本概念

- C++提供了数据抽象的手段，用户可以自己定义自己的数据类型--类，调用类的成员函数可以操作对象。

- 但是操作通过操作类的成员函数来操作对象很不方便，所有采用运算符重载

- 其目的是想对抽象的数据类型也能直接使用c++提供的运算符

- 运算符重载：

  - 对已有的运算符赋予多重的含义
  - 使同一运算符作用于不同类型的数据时，产生不同类型的行为

- 运算符重载的实质是函数重载

  ```c++
  返回值类型 operator 运算符 (形参表)
  {
      ....
  }
  ```

- 运算符可以被重载成普通函数，其参数个数为运算符目数

- 也可以被重载成类的成员函数，参数个数为运算符目数减一



## 赋值运算符的重载

- 对象可以用赋值运算符进行赋值
- 赋值运算符两边的类型可以不匹配，但是需要重新赋值运算符‘=’
- 赋值运算符‘=’只能重载为成员函数，不能重载为普通函数

## 运算符重载为友元函数

重载为友元函数的情况：

1. 成员函数不能满足使用要求
2. 普通函数又不能访问类的私有成员

## 实例 – 长度可变的整型数组类

## 流插入运算符和流提取运算符的重载

- cout是在iostream中定义得，ostream类的对象
- ‘<<’能用在cout上是因为，在iostream里对“<<”进行了重载



## 自增/自减运算符的重载 

- 自加、自减运算符有前置/后置之分

- 前置运算符作为一元运算符重载

  - 重载为成员函数

    T operator++();

    T operator--();

  - 重载为全局函数：

    T operator++(T);
    
    T operator--(T);
  
- 后置运算符作为二元运算符重载

  - 多写一个参数，具体无意义

  - 重载为成员函数

    T operator++(int);

    T operator--(int);

  - 重载为全局函数：

    T operator++(T,int);

    T operator--(T,int);

- 类型强制转换运算符重载时，
  - 不能写返回值类型
  - 实际上其返回值类型 就是 类型强制转换运算符代表的类型
- 运算符重载注意事项
  - c++不允许定义新的运算符
  - 重载后的运算符的含义应该符合日常习惯
  - 运算符重载不改变运算符的优先级
  - 以下运算符不能被重载：‘’.“，”.*“，”::“，”?:“，sizeof
  - 重载运算符(),[],->,=时，重载函数必须声明为类的成员函数

# 继承与派生

## 继承与派生

- 继承：在定义一个新的类B时，如果该类与某个已有的类A相似（B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类（子类）

- 派生类可以通过对基类进行修改和扩充得到。在派生类中，可以扩充新的成员函数和成员变量。

- 派生类一经定义，可以独立使用，不依赖与基类

- 派生类拥有基类的全部成员函数和成员变量，无论是private，protected，public

- 在派生类的各个成员函数中，不能访问基类中的private成员

- 派生类的写法是：

  ```c++
  类名:public 基类名
  ```

- 派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。

- 在派生类对象中，包含着基类的对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。

## 复合关系和继承关系

## 基类/派生类同名成员和protected访问范围说明符 

访问范围说明符：

- 基类的private成员：可以被下列函数访问：
  1. 基类的成员函数
  2. 基类的友元函数

- 基类的public成员：可以被下列函数访问：
  1. 基类的成员函数
  2. 基类的友元函数
  3. 派生类的成员函数
  4. 派生类的友元函数
  5. 其他的函数

- 基类的protected成员：可以被下列函数访问：
  1. 基类的成员函数
  2. 基类的友元函数
  3. 派生类的成员函数可以访问当前对象的基类的保护成员

## 派生类的构造函数

- 派生类对象包含基类对象

- 执行派生类构造函数之前， 先执行基类的构造函数

- 派生类交代基类初始化，具体形式：

  ```c++
  构造函数名(形参表):基类名(基类构造函数实参表)
  {
  }
  ```

- 在创建派生类的对象时：

  - 需要调用基类的构造函数：初始化派生类对象中从基类继承的成员
  - 在执行一个派生类的构造函数之前，总是先执行基类的构造函数

- 调用基类构造函数的两种方式

  1. 显式方式：

     派生类的构造函数中，基类构造函数提供参数

     ```c++
     T:T(arg_T-list):base(arg_base-list)
     ```

  2. 隐式方式：

     派生类的构造函数中，省略基类构造函数时，派生类的构造函数，自动调用基类的默认构造函数。

- 派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。
- 创建派生类的对象时，执行派生类的构造函数之前：
  1. 调用基类的构造函数，来初始化派生类对象中从基类继承的成员
  2. 调用成员对象类的构造函数，来初始化派生类对象中的成员函数
- 执行完派生类的析构函数后：
  1. 调用成员对象类的析构函数
  2. 调用基类的析构函数
- 析构函数的调用顺序和构造函数的调用顺序相反

## public继承的赋值兼容规则 

1. 派生类的对象可以赋值给基类对象
2. 派生类对象可以初始化基类引用
3. 派生类对象的地址可以赋值给基类指针
4. 如果派生方式是private或protected，则上述三条不可用

- 直接基类和间接基类 
  - 声明派生类时，只需列出它的直接基类，派生类会沿着类的层次自动向上继承他的间接基类
  - 派生类的成员包括：
    1. 派生类自己定义的成员
    2. 直接基类中的所有成员
    3. 所有间接基类的全部成员

# 多态与虚函数

## 多态与虚函数的基本概念

- 有类和继承等概念，但是没有多态的程序语言成为基于对象的程序语言，不能叫做面向对象的程序语言

- 在类的定义中，前面有virtual关键字的成员函数就是**虚函数**。

  ```c++
  class base{
  	virtual int get();
  };
  int base::get(){}
  ```

- virtual关键字只能用在类定义里的函数声明中，写函数体时不用

- 构造函数和静态成员函数不能是虚函数

- 虚函数可以参与多态，普通的成员函数不可以



多态：

- 多态的表现形式一：

  - 派生类的指针可以赋给基类指针
  - 通过基类指针调用基类和派生类中的同名虚函数时：
    - 若该指针指向一个基类的对象，那么被调用是基类的虚函数
    - 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数

- 多态的表现形式二：

  - 派生类的指针可以赋给基类引用
  - 通过基类引用调用基类和派生类中的同名虚函数时：
    - 若该引用引用的是一个基类的对象，那么被调用是基类的虚函数
    - 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数

- 多态的作用：

  能够增强程序的可扩充性

## 多态的实现原理

- 多态的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定--这叫动态联编
- 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。
- 多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。

## 虚析构函数

- 删除一个派生类的对象时，先调用派生类的析构函数，再调用基类的析构函数。
- 办法：把基类的析构函数声明为virtual
  - 派生类的析构函数virtual可以不进行声明
  - 通过基类的指针删除派生类对象时：首先调用派生类的析构函数，然后再调用基类的析构函数
- 类如果定义了虚函数，则最好将析构函数也定义成虚函数

## 纯虚函数和抽象类

- 纯虚函数：没有函数体的虚函数
- 抽象类：包含纯虚函数的类
  - 只能作为基类来派生新类使用
  - 不能创建抽象类对象
  - 抽象类的指针和引用  指向 由抽象类派生出来的类的对象
- 在抽象类中：
  - 在成员函数内可以调用纯虚函数
  - 在构造函数/析构函数内部不能调用纯虚函数
- 如果一个类从抽象类派生而来，它实现了基类中的所有纯虚函数，才能成为非抽象类

# 文件操作和模板

## 文件操作

- 顺序文件：一个有限字符构成的顺序字符流
- C++标准库中：ifstream，ofstream和fstream共3个类，用于文件操作，统称为文件流类
- 









































































​	