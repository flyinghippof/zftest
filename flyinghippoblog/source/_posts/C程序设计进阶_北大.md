---
title: C程序设计进阶_北大
date: 2020-10-14
tags:
---

学习笔记

<!-- more -->


# C程序中的函数

## 函数的定义与声明

定义：

```c
dataType  functionName( dataType1 param1, dataType2 param2 ... ){
    //body
}
```

- dataType 是返回值类型，它可以是C语言中的任意数据类型，例如 int、float、char 等。
- functionName 是函数名，它是[标识符](http://c.biancheng.net/view/1770.html)的一种，命名规则和标识符相同。函数名后面的括号`( )`不能少。
- body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由`{ }`包围。
- 如果有返回值，在函数体中使用 return 语句返回。return 出来的数据的类型要和 dataType 一样。
- `dataType1 param1, dataType2 param2 ...`是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由`,`分隔。参数本质上也是变量，定义时要指明类型和名称。

调用：

1. 函数调用作为独立语句，调用函数完成某项功能，没有任何的返回值
2. 函数作为表达式的一部分
3. 以实参形式出现在其他函数的调用中

头文件搜索路径：

- <>--默认搜索系统文件库
- “ ”--默认搜索当前文件路径

.h文件和.cpp文件的区别：

- 头文件（.h）：写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。
- 源文件（.cpp）： 源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。

注意：

1. 函数都是由类型的，函数的类型指的是函数返回值的数据类型。
2. 函数定义在main函数前边时，没有影响，定义在main函数后边时，需要先在前边做一个声明，形式为：函数的原型 = 返回值类型+函数名+参数类型，其中参数可不写名字

## 函数的调用过程

- main函数是函数运行的起点
- 实参和形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”
- 函数调用时，系统给形参分配存储单元，并将实参对应的值传递给形参
- 实参与形参的类型必须相同或可以兼容

函数参数传递的三种方式：

1. 值传递，就是把你的变量的值传递给函数的形式参数，实际就是用变量的值来新生成一个形式参数，因而在函数里对形参的改变不会影响到函数外的变量的值。
2. 地址传递，就是把变量的地址赋给函数里形式参数的指针，使指针指向真实的变量的地址，因为对指针所指地址的内容的改变能反映到函数外，能改变函数外的变量的值。
3. 引用传递，实际是通过指针来实现的，能达到使用的效果如传址，可是使用方式如传值。

## 变量的作用域

根据变量在程序中作用范围的不同，可以将变量分为：

- 局部变量：在函数内或块内定义，只在这个函数或块内起作用的变量
- 全局变量：在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件的结束

- 当全局变量与局部变量同名时，局部变量将在自己作用域内有效，他讲屏蔽同名的全局变量。
- 不在非常必要的情况下，不要使用全局变量，其有以下缺点：
  - 破坏了函数的“相对独立性”
  - 增加了函数之间的“耦合性”
  - 函数之间的交互不够清晰



## 数组做函数参数

- 数组的名字不是一个变量，是一个常量，是数组在内存中的地址
- 数组做函数参数时传递的是地址，所以数组本身会被改变
- 如果只是单纯的传入数组中的某一个值，那么还是传入的copy值

# 函数的递归
## 如何理解递归

- 函数不能嵌套定义
- 函数可以嵌套调用
- 递归：一个函数在其定义中直接或间接调用自身的一种方法
- 递归的作用：
  1. 用递归来完成递推：完成递推公式等
     1. 把关注点放在要求解的目标上
     2. 找到第n次和第n-1次执行之间的关系
     3. 确定第一次的返回结果
  2. 模拟连续发生的动作：
     1. 必须知道连续出现动作是什么
     2. 然后知道不同动作之间的关系
     3. 最后确定边界条件是什么。
  3. 进行“自动的分析”，eg：逆波兰表达式和放苹果。
     1. 先假设有一个函数能给出答案
     2. 然后利用这个函数的前提下，分析如何解决问题
     3. 搞清楚最简单的情况下答案是什么



# 指针（一）

## 什么是指针

- 变量三要素：变量的地址、变量的值、变量的名字
- 把变量的地址称为指向该变量的指针
- 可以利用取址运算符&来的得到变量的地址
- 一个变量的地址（指向该变量的指针）占用4个字节
- 可以利用指针运算符*来访问变量资源

## 什么是指针变量

- 专门用来存放指针（某个变量的地址）的变量，叫指针变量
- 指针变量里的指针是谁的指针我们就叫其是指向某个变量的指针变量
- 定义一个指针变量：
  1. int *pointer;--指针变量的基类型 ， 指针运算符（pointer的类型） ， 指针变量的名字
  2. 基类型：指针变量指向的变量的类型
- 访问指针变量指向的内容：
  1. 利用指针运算符*实现
  2. 如*pointer：其表示pointer所指向的存储单元的内容，**指的是变量，而不是变量具体的值**
- 指针变量也是变量，是变量就有地址
- 指针变量的定义和初始化：int *p1 = NULL;

## 指针变量++

不是把地址加1，而是按照指针变量对应的指针的大小来对地址进行加的操作

## 数组与指针

- 指针变量指向数组元素的时候，跟指向普通变量没有区别
- 数组名代表数组首元素的地址
- 数组名相当于指向数组第一个元素的指针
- 数组名不是变量，不能给其赋值

## 用指针访问数组

- 指针做加减操作时一定注意有效的范围

- 总结：

  1. 若定义：数组 int a[10]; 指针 int *pointer;
  2. 则：pointer = a; 等价于 pointer = &a[0];
  3. 数组访问：
     1. pointer + i 等价于 a + i 等价于 &a[i]  --指针变量加，要加其存的对应数据的大小
     2. \*（pointer + i ）等价于 \* （a + i  ） 等价于a[i]
  4. 表示形式：pointer[i] 等价于 *（pointer + i）




# 指针（二）

## 字符串与指针

- 直接打印字符串的变量名会直接打印整个字符串的内容
- 字符串的变量名也代表了字符串的首个元素的地址
- 如果要打印地址：cout<<static_cast<void*>(字符串变量名)<<endl;
- 可以把字符串直接赋给某个指针，但是不同通过这个指针去修改这个字符串的值，因为这个字符串是常量，程序运行时，常量放在单独的存储空间，只能去访问，不能修改

## 取地址与指针运算

- 当数组名出现在取地址符号&后边时，其返回的结果是指向这个数组的指针，而不是指向这个数组第一个元素的指针
- 对于一维数组：
  - 数组名相当于指向数组第一个元素的指针
  - 若a是指向数组第一个元素的指针，即a相当于&a[0]
  - &a是“指向数组”的指针，&a相当于管辖范围上升了一级
  - \*a是数组的第一个元素a[0]，\*a相当于管辖范围下降了一级

## 二维数组名的含义

- 二维数组是多个一维数组，所以其第一个元素是一个一维数组
- 规律：
  - a与&a[0]等价；
  - a[0]与&a\[0][0]等价
  - a[0]与*a等价
  - a\[0][0]与**a等价

## 用指针访问二维数组

- 定义一个指向“包含4个int型元素的一维数组”的指针变量：int (*p)[4];
- 如果像上方一样定义了数组和指针，则数组访问可写成 \*(\*(p+i)+j) 其中i，j表示行列
- 也可以直接写成p\[i]\[j]

# 指针（三）

## 指针做函数参数

- 可以给函数传递指针
- 可以将数组名作为实参赋给指针型形参
- c++编译器将形参数组名作为指针变量来处理：int (*p)[4]; = int p[]\[4]

## 限制指针实参的功能

- 符号常量声明语句：
  1. const 数据类型 常量名= 常量值；
  2. 数据类型 const 常量名= 常量值；
- 指向符号常量的指针：const int *p； 
- 因为传递给函数指针变量的时候，函数便可对原数据进行操作，如果不想让你改变传入数据的值，那么可以在定义函数形参时定义为指向符号常量的指针。
- 指向符号常量的指针具有的特性：
  1. 不能通过*pi的方式去修改其指向的相应存储单元的内容
  2. 可以修改其本身的值，可以指向不同的符号常量
  3. 可以指向一个普通的变量，但是也不能修改该变量的值

## 指针做函数返回值

- 返回指针类型数据的函数--int *function（int x, int y）;
- 确保返回的地址是有意义的，需要返回一个处于生命周期中的变量的地址
  - 返回全局变量的地址，而非局部变量的地址
  - 返回静态局部变量的地址，而非动态局部变量的地址

## 静态局部变量

- 定义：函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，在下一次该函数调用时，仍可以继续使用该变量
- 用关键词static进行声明，可将变量指定为“静态局部变量”。eg：static int value = 20；
- 如果定义了静态局部变量，等函数下一次调用时，其不会重新定义（赋初值等操作），会直接用

# 结构体与链表

## 结构体与结构体变量

- 新的数据类型--结构体：

```c
struct student
{
	int id;
    char name[20];
    float score;
};
```

- 定义结构体变量的方式

  1. 直接用已声明的结构体类型定义变量名。

     eg：student student1，student2；（结构体类型名 结构体变量名）

  2. 在声明类型的同时定义变量

     ```c
     struct student
     {
     	int id;
         char name[20];
         float score;
     }student1,student2;
     ```

## 结构体变量与函数

- 结构体赋值相当于copy了一份给对方
- 结构体做参数相当于copy了一份给函数，其跟数组名完全不同
- 结构体做返回值相当于copy一份给调用者

## 结构体变量与指针

- 可以定义指针变量指向结构体，然后访问的时候可以采用如下方式：
  1. （*student1）.id
  2. student1->id    --(->表示指向运算符，可以利用它对结构体变量的成员变量进行访问)

## 链表的定义

动态的申请内存空间：

- int *pint = new int(1024); delete pint;  --表示new一个内存空间，可以赋初始值1024，同时其返回地址的指针，存到pint中，如果需要删除，采用delete语句
- int *pia = new int[4]； delete [] pia;  --动态生成和删除数组型内存空间

链表的创建：

```c
struct student
{
    int id;
    student *next;
};

student *create()
{
 	student *head, *temp; int num,n=0;
    head = new student;
    temp = head;
    cin>>num;
    while(num!=-1)
    {
        n++;
        temp->id = num;
        temp->next = new student;
        temp = temp->next;
        cin>>num;
    }
    if(n==0)head = NULL;else temp->next = NULL;
    return head;
}
```

## 链表的操作

1. 链表的遍历

```c
student *pointer = create();
while (pointer->!=NULL)
{
	cout<<pointer->id<<endl;
    pointer = pointer->next;
}
```

2. 删除节点，在链表中将值为n的元素删掉

```c
student *dele(student *head;int n)
{
    student *temp,*follow;
    temp = head;
    if(head == NULL){  //空表的情况
        return(head)
    }
    if(head->num==n){   //第一个节点是要删除的目标
        head = head->next;
        delete temp;
        return(head);
    }
    while(temp != NULL && temp->num!=n){    //寻找要删除的目标
        follow = temp;
        temp = temp->next;
    }
    if(temp = NULL)cout<<"not found";    //没有找到要删除的目标
    else{
        follow->next = temp->next;
        delete temp;
    }
    return(head);
}
```

3. 插入操作，插入结点值为n的结点

```c
student *insert(student *head;int n)
{
    student *temp,*unit,*follow;
    temp = head; unit = new student;
    unit->num = n; unit -> next = NULL;
    if(head == NULL){  //空表的情况
        head = unit;
        return(head)
    }
    //寻找第一个不小于n或者结尾的结点temp
    while((temp->next != NULL) && (temp->num<n)){    //寻找要删除的目标
        follow = temp;
        temp = temp->next;
    }
    if(temp == head){    //如果temp为第一个节点
        unit->next = head;
        head = unit;
    }
    else{    //如果temp为最后一个节点
        if(temp->next = NULL)temp->next = unit;    
    	else{    //如果temp为一个中间节点
            follow->next = unit;
            unit->next = temp;
    	}
    }  
    return(head);
}
```

